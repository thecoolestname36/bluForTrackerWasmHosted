@page "/map/{formData}"
@using System.Drawing
@using System.Text
@using System.Text.Json
@using System.Collections.Concurrent
@using BluForTracker.Shared
@using Microsoft.AspNetCore.SignalR.Client
@implements IAsyncDisposable

<PageTitle>Map</PageTitle>
@if (string.IsNullOrEmpty(_error))
{
    <div id="map-container">
        <div id="map"></div>
        <div id="map-player-box">
            <table class="tableScrollable">
                <thead>
                    <tr>
                        <th>Username</th>
                        <th>Status</th>
                        <th>Age</th>
                        <th>Remove Icon</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach(var item in _markers)
                    {
                        <tr style="cursor:pointer; box-shadow:0px -16px 32px inset @item.Value.Color">
                            <td @onclick="async () => await SetCenter(item.Value)">@item.Value.Label</td>
                            <td @onclick="async () => await SetCenter(item.Value)">@(item.Value.Connected ? "Connected" : "Disconnected")</td>
                            <td @onclick="async () => await SetCenter(item.Value)">@MakeLastReportedAt(item.Value.UpdatedOn)</td>
                            <td><button @onclick="async () => await (await GetHubConnection()).SendAsync(Routing.MarkerHub.Server.RemoveMarker, item.Key)">REMOVE</button></td>
                        </tr>
                    }
                </tbody>
            </table>
        </div>
    </div>
} else
{
    <div id="error-box">@_error</div>
}

@code {

    [Inject]
    public required NavigationManager NavManager { get; set; }

    [Inject]
    public required IJSRuntime JSRuntime { get; set; }

    [Parameter]
    public required string FormData { get; set; }

    Index.MarkerFormModel? _formData = null;

    string? _error = null;

    HubConnection? _hubConnection;

    Timer? _renderTimer;

    ConcurrentDictionary<string, Marker> _markers = new();

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        _formData = JsonSerializer.Deserialize<Index.MarkerFormModel>(Encoding.UTF8.GetString(Convert.FromBase64String(FormData))) ?? new Index.MarkerFormModel();
        _formData.Label = _formData.Label[..Math.Min(Index.MarkerFormModel.LabelMaxChars, _formData.Label.Length)];
        try
        {
            ColorTranslator.FromHtml(_formData.Color);
        }
        catch
        {
            _formData.Color = "#000000";    
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        
        if(firstRender)
        {
            _error = null;
            await JSRuntime.InvokeVoidAsync("mapModule.watchPosition", DotNetObjectReference.Create(this));
            _renderTimer = new Timer(callback: new TimerCallback((state) =>
            {
                if(state is Map map)
                {
                    map.StateHasChanged();
                }
            }), this, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1));
        }
    }

    [JSInvokable]
    public async Task<HubConnection> GetHubConnection()
    {
        if(_hubConnection == null || _hubConnection.State == HubConnectionState.Disconnected)
        {
            var builder = new UriBuilder(NavManager.BaseUri);
            builder.Path += Routing.MarkerHub.Path;
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(builder.Uri)
                .Build();
            _hubConnection.On<ConcurrentDictionary<string, Marker>>(Routing.MarkerHub.Client.ReceiveMarkers, async (markers) =>
            {
                _markers = markers;
                StateHasChanged();
                await JSRuntime.InvokeVoidAsync("mapModule.updateMap", _markers);
            });
            _hubConnection.On<string, Marker>(Routing.MarkerHub.Client.ReceiveMarker, async (key, marker) =>
            {
                _markers[key] = marker;
                StateHasChanged();
                await JSRuntime.InvokeVoidAsync("mapModule.updateMap", _markers);
            });
            _hubConnection.On<string>(Routing.MarkerHub.Client.RemoveMarker, async (key) =>
            {
                _markers.TryRemove(key, out _);
                StateHasChanged();
                await JSRuntime.InvokeVoidAsync("mapModule.updateMap", _markers);
            });
            _hubConnection.On<string>(Routing.MarkerHub.Client.UserDisconnected, (key) =>
            {
                if(_markers.ContainsKey(key))
                {
                    _markers[key].Connected = false;
                    StateHasChanged();
                }
            });
            await _hubConnection.StartAsync();
        }
        while(_hubConnection.State != HubConnectionState.Connected)
        {
            await Task.Delay(TimeSpan.FromSeconds(1)); // Delay for 1 second
        }
        return _hubConnection;
    }

    [JSInvokable]
    public void WatchPositionErrorCallback()
    {
        NavManager.NavigateTo("/");
    }

    [JSInvokable]
    public async Task SendPosition(double lat, double lng)
    {
        await (await GetHubConnection()).SendAsync(Routing.MarkerHub.Server.BroadcastMarker, new Marker {
                Latitude = lat,
                Longitude = lng,
                Label = _formData?.Label ?? "",
                Color = _formData?.Color ?? "#000000",
                Connected = true
            });
        await Task.Delay(TimeSpan.FromSeconds(1)); // Delay for 1 second
        await JSRuntime.InvokeVoidAsync("mapModule.doneSendingPosition");
    }

    string MakeLastReportedAt(DateTimeOffset updatedOn)
    {

        var diff = DateTimeOffset.UtcNow - updatedOn;
        if (diff.TotalSeconds >= 15)
        {
            return new DateTime(diff.Ticks).ToString("m:ss");
        }
        return "";
    }

    async Task SetCenter(Marker marker) => await JSRuntime.InvokeVoidAsync("mapModule.setCenter", marker.Latitude, marker.Longitude);

    #region disposal

    public async ValueTask DisposeAsync()
    {
        if(_hubConnection != null)
        {
            await _hubConnection.DisposeAsync();
        }
    }

    #endregion
}
