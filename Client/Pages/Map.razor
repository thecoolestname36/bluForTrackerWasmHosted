@page "/map/{formData}"
@using System.Drawing
@using System.Text
@using System.Text.Json
@using System.Collections.Concurrent
@using Microsoft.AspNetCore.SignalR.Client
@using Blazored.LocalStorage
@using BluForTracker.Shared
@implements IAsyncDisposable

<PageTitle>Map</PageTitle>
<div id="map-container">
    <div id="map"></div>
    <div id="map-player-box">
        @if (_hubConnection?.State == HubConnectionState.Connected) {
            <table class="tableScrollable">
                <thead>
                    <tr>
                        <th>Username</th>
                        <th>Status</th>
                        <th>Age</th>
                        <th>Remove Icon</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var item in _markers)
                    {
                        <tr style="cursor:pointer; box-shadow:0px -16px 32px inset @item.Value.Color">
                            <td @onclick="async () => await SetCenter(item.Value)">@item.Value.Label</td>
                            <td @onclick="async () => await SetCenter(item.Value)">@(item.Value.Connected ? "Connected" : "Disconnected")</td>
                            @{
                                var age = "";
                                var diff = DateTimeOffset.UtcNow - item.Value.UpdatedOn;
                                if (diff.TotalSeconds >= 15)
                                {
                                    age = new DateTime(diff.Ticks).ToString("m:ss");
                                }
                            }
                            <td @onclick="async () => await SetCenter(item.Value)">@age</td>
                            <td><button type="button" class="btn btn-danger btn-sm btn-block" @onclick="async () => await RemoveMarker(item.Value.Id)">REMOVE</button></td>
                    </tr>
                }
            </tbody>
            </table>
        } else {
            switch(_hubConnection?.State) {
                case HubConnectionState.Connecting:
                case HubConnectionState.Reconnecting:
                    <div class="alert alert-warning" role="alert">@_hubConnection?.State.ToString()</div>
                    break;
                case HubConnectionState.Disconnected:
                    <div class="alert alert-danger" role="alert">@_hubConnection?.State.ToString()</div>
                    break;
                case null:
                default:
                    <div class="alert alert-secondary" role="alert">No hub connection</div>
                    break;
            }
        }
    </div>
</div>

@code {

    [Inject]
    public required NavigationManager NavManager { get; set; }

    [Inject]
    public required IJSRuntime JSRuntime { get; set; }

    [Inject]
    public required ILocalStorageService LocalStorage { get; set; }

    [Parameter]
    public required string FormData { get; set; }

    Index.MarkerFormModel? _formData = null;
    HubConnection? _hubConnection;
    ConcurrentDictionary<string, Marker> _markers = new();

    struct GeolocationCoordinates
    {
        public double Latitude { get; init; } 
        public double Longitude { get; init; }
    }

    GeolocationCoordinates? _currentLocation;

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        _formData = JsonSerializer.Deserialize<Index.MarkerFormModel>(Encoding.UTF8.GetString(Convert.FromBase64String(FormData))) ?? new Index.MarkerFormModel();
        _formData.Label = _formData.Label[..Math.Min(Index.MarkerFormModel.LabelMaxChars, _formData.Label.Length)];
        try
        {
            ColorTranslator.FromHtml(_formData.Color);
        }
        catch
        {
            _formData.Color = "#000000";    
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if(firstRender)
        {
            ViewRenderLoop();
            SendLocationLoop();
            await MapLoadLoop();
            await JSRuntime.InvokeVoidAsync("mapModule.addListenerOnceMapIdle", DotNetObjectReference.Create(this));
        }
    }

    PeriodicTimer? _viewRenderTimer;
    async void ViewRenderLoop()
    {
        _viewRenderTimer ??= new(TimeSpan.FromSeconds(1));
        while (await _viewRenderTimer.WaitForNextTickAsync())
        {
            StateHasChanged();
        }
    }

    PeriodicTimer? _sendLocationTimer;
    async void SendLocationLoop()
    {
        _sendLocationTimer ??= new(TimeSpan.FromMilliseconds(125));
        var sending = false;
        while(await _sendLocationTimer.WaitForNextTickAsync())
        {
            if(sending) continue;

            var hubConnection = await GetHubConnection();
            if(hubConnection.State == HubConnectionState.Connected && _currentLocation.HasValue)
            {
                var lat = _currentLocation.Value.Latitude;
                var lng = _currentLocation.Value.Longitude;
                _currentLocation = null;
                sending = true;
                await hubConnection.SendAsync(Routing.MarkerHub.Server.BroadcastMarker, new Marker
                    {
                        Latitude = lat,
                        Longitude = lng,
                        Label = _formData?.Label ?? "",
                        Color = _formData?.Color ?? "#000000",
                        Connected = true
                    });
                sending = false;
            }
        }
    }

    PeriodicTimer? _mapLoadTimer;
    async Task MapLoadLoop()
    {
        _mapLoadTimer ??= new(TimeSpan.FromMilliseconds(250));
        while(await _mapLoadTimer.WaitForNextTickAsync())
        {
            if(!(await JSRuntime.InvokeAsync<bool>("window.mapModule.isLoading")))
            {
                _mapLoadTimer.Dispose();
                return;
            }
        }
    }

    [JSInvokable]
    public void UpdateCurrentPosition(double lat, double lng) => _currentLocation = new GeolocationCoordinates
    {
        Latitude = lat,
        Longitude = lng
    };

    [JSInvokable]
    public void UpdateCurrentPositionError() => NavManager.NavigateTo("/");

    async Task RemoveMarker(string key)
    {
        var hubConnection = await GetHubConnection();
        if(hubConnection.State == HubConnectionState.Connected)
        {
            await hubConnection.SendAsync(Routing.MarkerHub.Server.RemoveMarker, key);
        }
    }

    async Task SetCenter(Marker marker) => await JSRuntime.InvokeVoidAsync("mapModule.setCenter", marker.Latitude, marker.Longitude);

    public async Task<HubConnection> GetHubConnection()
    {
        if (_hubConnection == null)
        {
            var builder = new UriBuilder(NavManager.BaseUri);
            builder.Path += Routing.MarkerHub.Path;
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(builder.Uri)
                .Build();
            _hubConnection.ServerTimeout = TimeSpan.FromSeconds(15);
            _hubConnection.KeepAliveInterval = TimeSpan.FromSeconds(5);
            _hubConnection.On<string>(Routing.MarkerHub.Client.ReceiveConnectionId, async (connectionId) =>
            {
                var oldConnectionId = await LocalStorage.GetItemAsStringAsync("connection_id");
                if(!string.IsNullOrEmpty(oldConnectionId))
                {
                    var hubConnection = await GetHubConnection();
                    if (hubConnection.State == HubConnectionState.Connected)
                    {
                        await hubConnection.SendAsync(Routing.MarkerHub.Server.RemoveMarker, oldConnectionId);
                    }
                }
                await LocalStorage.SetItemAsStringAsync("connection_id", connectionId);
            });
            _hubConnection.On<ConcurrentDictionary<string, Marker>>(Routing.MarkerHub.Client.ReceiveMarkers, async (markers) =>
            {
                _markers = markers;
                StateHasChanged();
                await JSRuntime.InvokeVoidAsync("mapModule.updateMap", _markers);
            });
            _hubConnection.On<Marker>(Routing.MarkerHub.Client.ReceiveMarker, async (marker) =>
            {
                _markers[marker.Id] = marker;
                StateHasChanged();
                await JSRuntime.InvokeVoidAsync("mapModule.updateMap", _markers);
            });
            _hubConnection.On<string>(Routing.MarkerHub.Client.RemoveMarker, async (key) =>
            {
                _markers.TryRemove(key, out _);
                StateHasChanged();
                await JSRuntime.InvokeVoidAsync("mapModule.updateMap", _markers);
            });
        }
        if (_hubConnection.State == HubConnectionState.Disconnected)
        {
            await _hubConnection.StartAsync();
        }
        return _hubConnection;
    }

    #region disposal

    public async ValueTask DisposeAsync()
    {
        if(_hubConnection != null)
        {
            await _hubConnection.DisposeAsync();
        }
        _viewRenderTimer?.Dispose();
        _mapLoadTimer?.Dispose();
        _sendLocationTimer?.Dispose();
    }

    #endregion
}
