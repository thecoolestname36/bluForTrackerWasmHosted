@page "/{version}/map"
@using System.Collections.Concurrent
@using Microsoft.AspNetCore.SignalR.Client
@using Blazored.LocalStorage
@using BluForTracker.Client.DataModels
@using BluForTracker.Shared
@inject IConfiguration Configuration
@implements IAsyncDisposable
<PageTitle>Map</PageTitle>

<div id="map-page-container">
    <div id="map-menu-container">
        <button type="button" class="btn btn-danger btn-lg" style="float:right" @onclick="Exit">Exit</button>
    </div>
    <div id="map-container">
        <div id="map"></div>
        <div id="map-player-box">
            @if(_hubConnection?.State == HubConnectionState.Connected)
            {
                <table class="tableScrollable">
                    <thead>
                    <tr>
                        <th style="width:100px">State</th>
                        <th style="width:160px" >
                            <button class="btn btn-block btn-outline-dark" @onclick="() => SetFrameOnClick(latitude: 40.12, longitude: -100.45, zoom: 4.0)">Username</button>
                        </th>
                        <th>Message</th>
                    </tr>
                    </thead>
                    <tbody>
                    @foreach (var item in _markers)
                    {
                        <tr style="cursor:pointer; box-shadow:0px -16px 32px inset @item.Value.Color">
                            <td style="width:100px">
                                @{
                                    var status = item.Value.Connected ? "Connected" : "Disconnected";
                                    var diff = DateTimeOffset.UtcNow - item.Value.UpdatedOn;
                                    if (diff.TotalSeconds < 15)
                                    {
                                        @status
                                    }
                                    else
                                    {
                                        <button type="button" class="btn btn-danger btn-sm btn-block" @onclick="async () => await RemoveMarker(item.Value.Id)">Stale (@(new DateTime(diff.Ticks).ToString("m:ss")))</button>
                                    }
                                }
                            </td>
                            <td style="width:160px">
                                <button class="btn btn-block btn-outline-dark" @onclick="() => SetFrameOnClick(item.Value)">@item.Value.Label</button>
                            </td>
                            @if (_infoMarkers.TryGetValue(item.Key, out var infoMarker))
                            {
                                <td>
                                    <button class="btn btn-block btn-outline-dark" @onclick="() => SetFrameOnClick(infoMarker)">@infoMarker.Message</button>
                                </td>
                            }
                            else
                            {
                                <td @onclick="() => SetFrameOnClick(item.Value)"></td>
                            }
                        </tr>
                    }
                    </tbody>
                </table>
            } else
            {
                switch(_hubConnection?.State)
                {
                    case HubConnectionState.Connecting:
                    case HubConnectionState.Reconnecting:
                        <div class="alert alert-warning" role="alert">@_hubConnection?.State.ToString()</div>
                        break;
                    case HubConnectionState.Disconnected:
                        <div class="alert alert-danger" role="alert">@_hubConnection?.State.ToString()</div>
                        break;
                    case null:
                    default:
                        <div class="alert alert-secondary" role="alert">No hub connection</div>
                        break;
                }
            }
        </div>
    </div>
</div>
<script async src="https://maps.googleapis.com/maps/api/js?key=@(Configuration.GetValue<string>("GoogleMapsApiKey"))&callback=window.mapModule.mapsCallback&libraries=maps,marker"></script>

@code {

    [Inject]
    public required NavigationManager NavManager { get; set; }

    [Inject]
    public required IJSRuntime JSRuntime { get; set; }

    [Inject]
    public required ILocalStorageService LocalStorage { get; set; }

    [Parameter]
    public required string Version { get; set; }

    struct GeolocationCoordinates
    {
        public required double Latitude { get; init; }
        public required double Longitude { get; init; }
    }

    IJSObjectReference? _mapModuleJs = default!;
    GeolocationCoordinates? _currentLocation;
    InfoMarker? _myInfoMarker;
    CurrentUserModel? _currentUser = null;
    HubConnection? _hubConnection;
    ConcurrentDictionary<string, Marker> _markers = new();
    ConcurrentDictionary<string, InfoMarker> _infoMarkers = new();
    CancellationTokenSource _jobTokenSource = new();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        
        if(firstRender)
        {
            if (!await LocalStorage.ContainKeyAsync(nameof(UserStore)) ||
                (_currentUser = (await LocalStorage.GetItemAsync<UserStore>(nameof(UserStore)))?.ToCurrentUserModel()) == null)
            {
                // No user set, redirect to user page
                NavManager.NavigateTo($"/", true);
            }
            
            var collocatedJs = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./Pages/Map.razor.js");
            // TODO - Convert this to a JS Interop with JSImport
            _mapModuleJs = await collocatedJs.InvokeAsync<IJSObjectReference>("CreateMapModule");
            await MapLoadLoop();
            await GetHubConnection();
            ViewRenderLoop();
            SendLocationLoop();
            SendMyInfoMarkerLoop();
        }
    }

    PeriodicTimer? _mapLoadTimer;
    async Task MapLoadLoop()
    {
        if (_jobTokenSource.IsCancellationRequested) return;
        
        _mapLoadTimer ??= new(TimeSpan.FromMilliseconds(125));
        while(await _mapLoadTimer.WaitForNextTickAsync(_jobTokenSource.Token))
        {
            if(await _mapModuleJs.InvokeAsync<bool>("isGoogleMapsApiLoading")) continue;
            await _mapModuleJs.InvokeVoidAsync("addListenerOnceMapIdle", DotNetObjectReference.Create(this));
            _mapLoadTimer.Dispose();
            _mapLoadTimer = null;
            return;
        }
    }

    PeriodicTimer? _viewRenderTimer;
    async void ViewRenderLoop()
    {
        if (_jobTokenSource.IsCancellationRequested) return;
        
        _viewRenderTimer ??= new(TimeSpan.FromSeconds(1));
        while(await _viewRenderTimer.WaitForNextTickAsync(_jobTokenSource.Token))
        {
            StateHasChanged();
        }
    }

    PeriodicTimer? _sendLocationTimer;
    async void SendLocationLoop()
    {
        if (_jobTokenSource.IsCancellationRequested) return;
        
        _sendLocationTimer ??= new(TimeSpan.FromMilliseconds(125));
        var sending = false;
        while(await _sendLocationTimer.WaitForNextTickAsync(_jobTokenSource.Token))
        {
            if(sending) continue;

            var hubConnection = await GetHubConnection();
            if(hubConnection.State == HubConnectionState.Connected && _currentLocation.HasValue)
            {
                var marker = new Marker
                    {
                        Latitude = _currentLocation.Value.Latitude,
                        Longitude = _currentLocation.Value.Longitude,
                        Team = _currentUser?.Team ?? Team.None,
                        Label = _currentUser?.Label ?? "",
                        Color = _currentUser?.Color ?? "#000000",
                        Connected = true
                    };
                _currentLocation = null;
                sending = true;
                await hubConnection.SendAsync(Routing.MarkerHub.Server.BroadcastMarker, marker);
                sending = false;
            }
        }
    }

    PeriodicTimer? _sendMyInfoMarkerTimer;
    async void SendMyInfoMarkerLoop()
    {
        if (_jobTokenSource.IsCancellationRequested) return;
        
        _sendMyInfoMarkerTimer ??= new(TimeSpan.FromSeconds(1));
        var sending = false;
        while(await _sendMyInfoMarkerTimer.WaitForNextTickAsync(_jobTokenSource.Token))
        {
            if(sending) continue;

            var hubConnection = await GetHubConnection();
            if(hubConnection.State == HubConnectionState.Connected && _myInfoMarker != null)
            {
                var infoMarker = new InfoMarker
                    {
                        Team = _currentUser?.Team ?? Team.None,
                        Label = _myInfoMarker.Label,
                        LabelColor = _myInfoMarker.LabelColor,
                        Message = _myInfoMarker.Message,
                        Latitude = _myInfoMarker.Latitude,
                        Longitude = _myInfoMarker.Longitude
                    };
                _myInfoMarker = null;
                sending = true;
                await hubConnection.SendAsync(Routing.MarkerHub.Server.BroadcastInfoMarker, infoMarker);
                sending = false;
            }
        }
    }

    [JSInvokable]
    public void UpdateCurrentPosition(double lat, double lng) => _currentLocation = new GeolocationCoordinates
        {
            Latitude = lat,
            Longitude = lng
        };

    [JSInvokable]
    public void UpdateCurrentPositionError() => NavManager.NavigateTo($"/", true);

    [JSInvokable]
    public void UpdateMyInfoMarker(string message, double lat, double lng) => _myInfoMarker = new InfoMarker()
        {
            Team = _currentUser?.Team ?? Team.None,
            Label = _currentUser?.Label ?? "unk",
            LabelColor = _currentUser?.Color ?? "#000000",
            Message = string.IsNullOrEmpty(message) ? "" : message,
            Latitude = lat,
            Longitude = lng
        };

    [JSInvokable]
    public async Task RemoveInfoMarker(string key)
    {
        var hubConnection = await GetHubConnection();
        if(hubConnection.State == HubConnectionState.Connected)
        {
            await hubConnection.SendAsync(Routing.MarkerHub.Server.RemoveInfoMarker, key);
        }
    }

    async Task RemoveMarker(string key)
    {
        var hubConnection = await GetHubConnection();
        if(hubConnection.State == HubConnectionState.Connected)
        {
            await hubConnection.SendAsync(Routing.MarkerHub.Server.RemoveMarker, key);
        }
    }

    async Task Exit()
    {
        var hubConnection = await GetHubConnection();
        if(hubConnection.State == HubConnectionState.Connected)
        {
            await LocalStorage.ClearAsync();
            await hubConnection.SendAsync(Routing.MarkerHub.Server.Exit);
            //await DisposeAsync();
            NavManager.NavigateTo($"/", true);
        }
    }

    Task SetFrameOnClick(Marker marker) => SetFrameOnClick(marker.Latitude, marker.Longitude);
    
    Task SetFrameOnClick(InfoMarker marker) => SetFrameOnClick(marker.Latitude, marker.Longitude);

    Task SetFrameOnClick(double latitude, double longitude, double zoom = 16.0) => Task.WhenAll([
        _mapModuleJs?.InvokeVoidAsync("setCenter", latitude, longitude).AsTask() ?? Task.CompletedTask,
        _mapModuleJs?.InvokeVoidAsync("setZoom", zoom).AsTask() ?? Task.CompletedTask,
    ]);

    public async Task<HubConnection> GetHubConnection()
    {
        if (_hubConnection == null)
        {
            var builder = new UriBuilder(NavManager.BaseUri);
            builder.Path += Routing.MarkerHub.Path;
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(builder.Uri)
                .Build();
            _hubConnection.ServerTimeout = TimeSpan.FromSeconds(15);
            _hubConnection.KeepAliveInterval = TimeSpan.FromSeconds(5);
            _hubConnection.On<string>(Routing.MarkerHub.Client.ReceiveConnectionId, async (connectionId) =>
            {
                var oldConnectionId = await LocalStorage.GetItemAsStringAsync("connection_id");
                if (!string.IsNullOrEmpty(oldConnectionId))
                {
                    var hubConnection = await GetHubConnection();
                    if (hubConnection.State == HubConnectionState.Connected)
                    {
                        await hubConnection.SendAsync(Routing.MarkerHub.Server.UpdateConnectionId, oldConnectionId, _currentUser?.Team ?? Team.None, _currentUser?.Color ?? "#000000");
                    }
                }
                await LocalStorage.SetItemAsStringAsync("connection_id", connectionId);
            });
            _hubConnection.On<List<Marker>>(Routing.MarkerHub.Client.SyncMarkers, async (markers) =>
            {
                _markers = new ConcurrentDictionary<string, Marker>(
                    markers.Where(marker => marker.Team == _currentUser?.Team).Select(marker => new KeyValuePair<string, Marker>(marker.Id, marker)));
                StateHasChanged();
                await _mapModuleJs.InvokeVoidAsync("syncMarkers", _markers.Values.ToList());
            });
            _hubConnection.On<Marker>(Routing.MarkerHub.Client.ReceiveMarker, async (marker) =>
            {
                if (marker.Team == _currentUser?.Team)
                {
                    _markers[marker.Id] = marker;
                    StateHasChanged();
                    await _mapModuleJs.InvokeVoidAsync("receiveMarker", marker);
                }
            });
            _hubConnection.On<string>(Routing.MarkerHub.Client.RemoveMarker, async (key) =>
            {
                _markers.TryRemove(key, out _);
                StateHasChanged();
                await _mapModuleJs.InvokeVoidAsync("removeMarker", key);
            });
            _hubConnection.On<string>(Routing.MarkerHub.Server.Exit, (key) =>
            {
                _markers.TryRemove(key, out _);
                _infoMarkers.TryRemove(key, out _);
                StateHasChanged();
                _mapModuleJs?.InvokeVoidAsync("removeMarker", key);
                _mapModuleJs?.InvokeVoidAsync("removeInfoMarker", key);
            });

            _hubConnection.On<List<InfoMarker>>(Routing.MarkerHub.Client.SyncInfoMarkers, async (infoMarkers) =>
            {
                var list = infoMarkers.Where(infoMarker => infoMarker.Team == _currentUser?.Team).ToList();
                _infoMarkers.Clear();
                list.ForEach(m => _infoMarkers.TryAdd(m.Id, m));
                await _mapModuleJs.InvokeVoidAsync("syncInfoMarkers", list);
            });
            _hubConnection.On<InfoMarker>(Routing.MarkerHub.Client.ReceiveInfoMarker, async (infoMarker) =>
            {
                if (infoMarker.Team == _currentUser?.Team)
                {
                    _infoMarkers.AddOrUpdate(infoMarker.Id, infoMarker, (key, value) => infoMarker);
                    await _mapModuleJs.InvokeVoidAsync("receiveInfoMarker", infoMarker);
                }
            });
            _hubConnection.On<string>(Routing.MarkerHub.Client.RemoveInfoMarker, async (key) =>
            {
                _infoMarkers.TryRemove(key, out _);
                await _mapModuleJs.InvokeVoidAsync("removeInfoMarker", key);
            });
        }
        if(_hubConnection.State == HubConnectionState.Disconnected)
        {
            await _hubConnection.StartAsync();
        }
        return _hubConnection;
    }

    #region disposal

    public async ValueTask DisposeAsync()
    {
        try
        {
            await _jobTokenSource.CancelAsync();
        }
        catch { }
        
        _markers.Clear();
        _currentLocation = null;
        _currentUser = null;
        if(_hubConnection != null)
        {
            await _hubConnection.StopAsync();
            await _hubConnection.DisposeAsync();
            _hubConnection = null;
        }
        if(_mapModuleJs != null)
        {
            await _mapModuleJs.DisposeAsync();
            _mapModuleJs = null;
        }
        _viewRenderTimer?.Dispose();
        _viewRenderTimer = null;
        _mapLoadTimer?.Dispose();
        _mapLoadTimer = null;
        _sendLocationTimer?.Dispose();
        _sendLocationTimer = null;
        _sendMyInfoMarkerTimer?.Dispose();
        _sendMyInfoMarkerTimer = null;
    }

    #endregion
}
